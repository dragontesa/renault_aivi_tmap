/*
 * This file was generated by qdbusxml2cpp version 0.7
 * Command line was: qdbusxml2cpp -p AudioManagerInterface com.bosch.AutomotiveProxy.AudioManager.xml
 *
 * qdbusxml2cpp is Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
 *
 * This is an auto-generated file.
 * Do not edit! All changes made to it will be lost.
 */

#ifndef AUDIOMANAGERINTERFACE_H_1525764959
#define AUDIOMANAGERINTERFACE_H_1525764959

#include <QtCore/QObject>
#include <QtCore/QByteArray>
#include <QtCore/QList>
#include <QtCore/QMap>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtCore/QVariant>
#include <QtDBus/QtDBus>
#include "ThirdPartyVoiceIF.h"

/*
 * Proxy class for interface com.bosch.AutomotiveProxy.AudioManager
 */

typedef struct
{
    uchar devType;
    QString devName;
} SINKINFO;

QDBusArgument &operator<<(QDBusArgument &argument, const SINKINFO& sinkInfo);
const QDBusArgument &operator>>(const QDBusArgument &argument, SINKINFO &sinkInfo);

Q_DECLARE_METATYPE(SINKINFO)


class third::party::voice::ThirdPartyVoiceIF;
class ComBoschAutomotiveProxyAudioManagerInterface: public QDBusAbstractInterface
{
    Q_OBJECT
public:
    static inline const char *staticInterfaceName()
    { return "com.bosch.AutomotiveProxy.AudioManager"; }

public:
    ComBoschAutomotiveProxyAudioManagerInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);

    ~ComBoschAutomotiveProxyAudioManagerInterface();
private:
   third::party::voice::ThirdPartyVoiceIF* m_pThirdPartyVoiceIF;

public Q_SLOTS: // METHODS
    inline QDBusPendingReply<bool> AudioRouteRequest(uchar source, uchar state_required)
    {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(source) << QVariant::fromValue(state_required);
        return asyncCallWithArgumentList(QLatin1String("AudioRouteRequest"), argumentList);
    }

    inline QDBusPendingReply<> MuteState(uchar source, bool state_required)
    {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(source) << QVariant::fromValue(state_required);
        return asyncCallWithArgumentList(QLatin1String("MuteState"), argumentList);
    }

    inline QDBusPendingReply<> SourceActivityResult(uchar source, ushort status)
    {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(source) << QVariant::fromValue(status);
        return asyncCallWithArgumentList(QLatin1String("SourceActivityResult"), argumentList);
    }

    inline QDBusPendingReply<> SourceAvailability(uchar source, bool availability)
    {
        QList<QVariant> argumentList;
        argumentList << QVariant::fromValue(source) << QVariant::fromValue(availability);
        return asyncCallWithArgumentList(QLatin1String("SourceAvailability"), argumentList);
    }

Q_SIGNALS: // SIGNALS
    void OnAllocate(uchar source, QList<SINKINFO> sink);
    void OnDeAllocate(uchar source);
    void OnMuteState(uchar source, uchar mute_state);
    void SourceActivity(uchar source, ushort status);

//private slots:
//    void toOnAllocate(uchar source, const QString &sink);
//    void toOnDeAllocate(uchar source);
//    void toOnMuteState(uchar source, uchar mute_state);
//    void toSourceActivity(uchar source, ushort status);
};


namespace com {
  namespace bosch {
    namespace AutomotiveProxy {
      typedef ::ComBoschAutomotiveProxyAudioManagerInterface AudioManager;
    }
  }
}
#endif
