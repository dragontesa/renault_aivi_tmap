/*
 * This file was generated by qdbusxml2cpp version 0.8
 * Command line was: qdbusxml2cpp -a navigationserviceadaptor -i navigationservicetype.h NavigationService_qdbus.xml
 *
 * qdbusxml2cpp is Copyright (C) 2015 Digia Plc and/or its subsidiary(-ies).
 *
 * This is an auto-generated file.
 * Do not edit! All changes made to it will be lost.
 */

#include "navigationserviceadaptor.h"
#include "navigationserver.h"
#include <QtCore/QMetaObject>
#include <QtCore/QByteArray>
#include <QtCore/QList>
#include <QtCore/QMap>
#include <QtCore/QString>
#include <QtCore/QStringList>
#include <QtCore/QVariant>

static const QString NavigationServiceInterface = QStringLiteral("org.bosch.cm.navigation.NavigationService");

/*
 * Implementation of adaptor class NavigationServiceAdaptor
 */

NavigationServiceAdaptor::NavigationServiceAdaptor(NavigationServer *parent)
    : QDBusAbstractAdaptor(parent),
    m_Service(parent)
{
    // adaptor must have the service for itself.
    if (parent == nullptr) {
        m_Service = new NavigationServer();
    }

    // constructor
    setAutoRelaySignals(false);
}

NavigationServiceAdaptor::~NavigationServiceAdaptor()
{
    // destructor
}

/**
 * \brief Attribute provides over speed sound alert status information
 */
bool NavigationServiceAdaptor::OverSpeedSoundAlertInfoActive() const
{
    return m_Service->OverSpeedSoundAlertInfoActive();
}

/**
 * \brief Property to send all ETD, ETA and other information. Cluster
 * 
 * NOK -  2018.08.10 SKT can not get the car consumtion and calculate it to Destination, 
 */
NSArrivalInformationList NavigationServiceAdaptor::arrivalInformationList() const
{
    // get the value of property arrivalInformationList
    return m_Service->arrivalInformationList();
}

/**
 * \brief If a turn is coming , bargraph will indicate how much(%) remaining distance
 * vehicle need to cover before turn. Cluster
 */
NSBarGraphInfo NavigationServiceAdaptor::barGraphInfo() const
{
    // get the value of property barGraphInfo
    return m_Service->barGraphInfo();
}

/**
 * \brief Property to show current street . TCU
 */
QString NavigationServiceAdaptor::currentStreet() const
{
    // get the value of property currentStreet
    return m_Service->currentStreet();
}

QString NavigationServiceAdaptor::datasetVersion() const
{
    // get the value of property datasetVersion
    return m_Service->datasetVersion();
}

/**
 * \brief Property to provide detail information about destination. VR
 *
 * This attribute is used to determine the current active number of destinations.
 * This is required when we request for a POI search. 
 * For POI search we have to provide the destinationindex as one of the parameter 
 * which can be identified only by this attribute.This is determined by the size of the destinationInformation.
 */
NSDestinationInfoElements NavigationServiceAdaptor::destinationInformation() const
{
    // get the value of property destinationInformation
    return m_Service->destinationInformation();
}

/**
 * \brief Attribute provides the route reached status like WAYPOINT, FINAL DESTINATION
 */
uint NavigationServiceAdaptor::destinationReachedStatus() const
{
    return m_Service->destinationReachedStatus();
}

/**
 * \brief Property to provide the round about Exit Number. TCU, cluster
 */
NSDistanceToDestination NavigationServiceAdaptor::distanceToDestination() const
{
    // get the value of property distanceToDestination
    return m_Service->distanceToDestination();
}

NSHomeLocation NavigationServiceAdaptor::homeLocation() const
{
    // get the value of property homeLocation
    return m_Service->homeLocation();
}

bool NavigationServiceAdaptor::isAddressBookChanged() const
{
    // get the value of property isAddressBookChanged
    return m_Service->isAddressBookChanged();
}

/**
 * \brief Property to provide info if LastDestination list has to be requested again using 
 *  the method requestDestinationMemoryEntries
 *
 * Attribute is updated when there is a change in the previous destination list.
 * This includes when a new entry is added or deleted
 */
bool NavigationServiceAdaptor::isLastDestinationListChanged() const
{
    // get the value of property isLastDestinationListChanged
    return m_Service->isLastDestinationListChanged();
}

/**
 * \brief Attribute provides voice guidance status.
 */
bool NavigationServiceAdaptor::isVoiceGuidanceActive() const
{
    // get the value of property isVoiceGuidanceActive
    return m_Service->isVoiceGuidanceActive();
}

/**
 * \brief Property to send number of lanes, lane charecteristics and lane directions. Cluster
 */
NSLaneRecommendationList NavigationServiceAdaptor::laneRecommendationList() const
{
    // get the value of property laneRecommendationList
    return m_Service->laneRecommendationList();
}

uint NavigationServiceAdaptor::maneuverSymbol() const
{
    // get the value of property maneuverSymbol
    return m_Service->maneuverSymbol();
}

NSManeuverView NavigationServiceAdaptor::maneuverView() const
{
    // get the value of property maneuverView
    return m_Service->maneuverView();
}

uint NavigationServiceAdaptor::mapRepresentation() const
{
    // get the value of property mapRepresentation
    return m_Service->mapRepresentation();
}

NSMapVideoStreamResult NavigationServiceAdaptor::mapVideoStreamStatus() const
{
    // get the value of property mapVideoStreamStatus
    return m_Service->mapVideoStreamStatus();
}

/**
 * \brief Attribute provides POI Category Shortcut Names in current selected language. TCU
 */
NSPoiCategoryShortcuts NavigationServiceAdaptor::menuPoiCategoryShortcuts() const
{
    // get the value of property menuPoiCategoryShortcuts
    return m_Service->menuPoiCategoryShortcuts();
}


/**
 * \brief Enum for navigation status information
 *
 * NAVSTATUS_IDLE  When the navigation system isin idle state.
 * NAVSTATUS_GUIDANCE_ACTIVE  When there is an ongoing active route guidance.
 * NAVSTATUS_CALCULATING_ROUTE  When a destination is set and navi is calculating the route i.e before the guidance is started.
 * NAVSTATUS_GUIDANCE_ACTIVE_OFFBOARD  When there is an turn-by-turn navigation supported from external systems like onstar for US regions.(Not supported for AIVI)
 */
uint NavigationServiceAdaptor::navStatus() const
{
    // get the value of property navStatus
    return m_Service->navStatus();
}

/**
 * \brief Property to provide next maneuver details. cluster, TBT
 */
NSNextManeuverDetails NavigationServiceAdaptor::nextManeuverDetails() const
{
    // get the value of property nextManeuverDetails
    return m_Service->nextManeuverDetails();
}

/**
 * \brief Property to show next turn street name. Cluster
 */
QString NavigationServiceAdaptor::nextTurntoStreet() const
{
    // get the value of property nextTurntoStreet
    return m_Service->nextTurntoStreet();
}

NSPositionInformation NavigationServiceAdaptor::positionInformation() const
{
    // get the value of property positionInformation
    return m_Service->positionInformation();
}

/**
 * \brief Property to provide the round about Exit Number. Cluster
 */
ushort NavigationServiceAdaptor::roundaboutExitNumber() const
{
    // get the value of property roundaboutExitNumber
    return m_Service->roundaboutExitNumber();
}

/**
 * \brief Property to provide route calculation duration .
 */
NSRouteCalculationDuration NavigationServiceAdaptor::routeCalculationDuration() const
{
    // get the value of property routeCalculationDuration
    return m_Service->routeCalculationDuration();
}

void NavigationServiceAdaptor::setRouteCalculationDuration(NSRouteCalculationDuration value)
{
    // set the value of property routeCalculationDuration
    m_Service->setRouteCalculationDuration(value);
}

/**
 * \brief Attribute provides the reason for the route re-calculation
 * @return value by RouteRecalculationReason
 */
uint NavigationServiceAdaptor::routeRecalculationReason() const
{
    return m_Service->routeRecalculationReason();
}

/**
 * \brief Property to provide satellite sensor information
 */
NSSatelliteInfo NavigationServiceAdaptor::satelliteInfo() const
{
    // get the value of property satelliteInfo
    return m_Service->satelliteInfo();
}

/**
 * \brief Property to provide the current SDS address entry. VR
 *
 * Speech requests for an address search via method call.
 * The result may require further refining.These refining can be like ambiguous address or house number validation.
 * In some cases it may be an invalid address too.
 * These informations are sent in the form of property update by navigation to VR system.This will have detailed description on every part of the address like state , city. These results will be evaluated by VR system and based on this further action would be taken
 */
NSSDSAddressWithOptions NavigationServiceAdaptor::sdsAddressWithOptions() const
{
    // get the value of property sdsAddressWithOptions
    return m_Service->sdsAddressWithOptions();
}

NSSpeedLimit NavigationServiceAdaptor::speedLimit() const
{
    // get the value of property speedLimit
    return m_Service->speedLimit();
}

NSTrafficEnforcement NavigationServiceAdaptor::trafficEnforcement() const
{
    return m_Service->trafficEnforcement();
}

void NavigationServiceAdaptor::setTrafficEnforcement(NSTrafficEnforcement value)
{
    // set the value of property trafficEnforcement
//    parent()->setProperty("trafficEnforcement", QVariant::fromValue(value));
	m_Service->setTrafficEnforcement(value);
}

/**
 * \brief Property to show turn street name street. Cluster
 */
NSTurnToStreet NavigationServiceAdaptor::turntoStreet() const
{
    // get the value of property turntoStreet
    return m_Service->turntoStreet();
}

/**
 * \brief Property to provide inserted waypoints details on property update. VR
 *
 * Navigation updates this property on the waypoints that are currently active. 
 * VR system will get this property update only when it calls the RequestWayPoinList method.
 * This will not be triggered whenever the waypoint list changes.
 */
NSWaypointList NavigationServiceAdaptor::waypointList() const
{
    // get the value of property waypointList
    return m_Service->waypointList();
}

NSWaypointOpertaionStatusList NavigationServiceAdaptor::waypointOperationStatusList() const
{
    return m_Service->waypointOperationStatusList();
}

NSWorkLocation NavigationServiceAdaptor::workLocation() const
{
    // get the value of property workLocation
    return m_Service->workLocation();
}

/**
 * \brief Uses modified waypoint list and trigger new route calculation. VR
 *
 * If VR is requesting to insert a waypoint to navigation followed by that it should 
 * call the applyWaypointListChange method to apply the change for inserting a new waypoint.
 * This is a trigger to re calculate the route for the new destination
 */
void NavigationServiceAdaptor::applyWaypointListChange()
{
    qDebug() << "[INTERFACE] NavigationServiceAdaptor::applyWaypointListChange()";

    // handle method call org.bosch.cm.navigation.NavigationService.applyWaypointListChange
    m_Service->applyWaypointListChange();
}

/**
 * \brief  Method will stop the active route guidance. VR
 *
 *  There will not be any confirmation pop up in HMI instead directly route will be stopped.
 */
void NavigationServiceAdaptor::cancelRouteGuidance()
{
    // handle method call org.bosch.cm.navigation.NavigationService.cancelRouteGuidance
    m_Service->doCancelRouteGuidance();
}

NSMapVideoStreamResult NavigationServiceAdaptor::deleteMapVideoStream(uint mapVideoStreamHandle)
{
    // handle method call org.bosch.cm.navigation.NavigationService.deleteMapVideoStream
    qDebug() << Q_FUNC_INFO << ", handle: " << mapVideoStreamHandle;

    return m_Service->deleteMapVideoStream(mapVideoStreamHandle);
}

/**
 * \brief Delete the waypoints (including firstIndex and lastIndex).
 */
void NavigationServiceAdaptor::deleteWaypoints(uint firstIndex, uint lastIndex)
{
    // handle method call org.bosch.cm.navigation.NavigationService.deleteWaypoints
    m_Service->deleteWaypoints(firstIndex, lastIndex);
}

NSNavDataPartNumber NavigationServiceAdaptor::getNavDataPartNumber()
{
    return m_Service->getNavDataPartNumber();
}

/**
 * \brief Get the customized preferred category shortcuts. TCU
 */
NSPoiCategoryShortcuts NavigationServiceAdaptor::getPoiCategoryShortcuts()
{
    // handle method call org.bosch.cm.navigation.NavigationService.getPoiCategoryShortcuts
    return m_Service->getPoiCategoryShortcuts();
}

/**
 * \brief Request will respond with the current NavMiddleware version string.
 */
QString NavigationServiceAdaptor::getVersionString()
{
    // handle method call org.bosch.cm.navigation.NavigationService.getVersionString
    return m_Service->getVersionString();
}

void NavigationServiceAdaptor::insertWaypoint(uint newIndex)
{
    // handle method call org.bosch.cm.navigation.NavigationService.insertWaypoint
    m_Service->insertWaypoint(newIndex);
}

/** 
 * Inserts current location as new waypoint in current waypoint list.
 * Index: Index internally defined by navigation application.
 * Once waypoint inserted property update ROUTE_WAYPOINTINFOS_CHANGED provides waypoint list
 * note! added from SWID NavigaitonService 1.17
 */
void NavigationServiceAdaptor::insertWaypointAtDefaultPosition()
{
    m_Service->insertWaypointAtDefaultPosition();
}

/**
 * \brief Requests to modify the MapVideoStream of the cluster.
 */
NSMapVideoStreamResult NavigationServiceAdaptor::modifyMapVideoStream(uint mapVideoStreamHandle, NSMapVideoStreamDimensions mapVideoStreamDimensions, ushort videoType)
{
    // handle method call org.bosch.cm.navigation.NavigationService.modifyMapVideoStream
    return m_Service->modifyMapVideoStream(mapVideoStreamHandle, mapVideoStreamDimensions, videoType);
}

/**
 * \brief Request will get the version tag of navigation delivery
 */
QString NavigationServiceAdaptor::navigationVersion()
{
    return m_Service->navigationVersion();
}

/**
 * \brief Uses current location to replace waypoint. ManageApp
 */
void NavigationServiceAdaptor::replaceWaypoint(uint index)
{
    // handle method call org.bosch.cm.navigation.NavigationService.replaceWaypoint
    m_Service->replaceWaypoint(index);
}

/**
 * \brief Request will return DestinationMemory entries for the given category. VR
 *
 * Method will return the list of addresses that are stored in either the address book or 
 * rhe destinations that have been previously set. 
 * VR when calling this method has to request the destination memory categoty type.
 * The types ar either address book or peviosu destinations.
 * The result will include list of addresses and/or POI’s .
 */
NSDestinationMemoryDetailsList NavigationServiceAdaptor::requestDestinationMemoryEntries(uint categoryType)
{
    // handle method call org.bosch.cm.navigation.NavigationService.requestDestinationMemoryEntries
    return m_Service->requestDestinationMemoryEntries(categoryType);
}

/**
 * \brief Request will respond with location details for the selected location set via 
 * setLocationWithXYZ interface. VR
 *
 * VR system calls this interface to get the phonenumber of the selected POI.
 * Navigation to handover the phonenumber to the VR system so that the suer can call 
 * the corresponding POI via connected phone.
 */
NSLocationDetails NavigationServiceAdaptor::requestDetailsForSelectedLocation()
{
    // handle method call org.bosch.cm.navigation.NavigationService.requestDetailsForSelectedLocation
    return m_Service->requestDetailsForSelectedLocation();
}

/**
 * \brief Requests the specified range of free text search results for the search string and scope. TCU, VR
 *
 * VR will call this interface when they want to do a POI brand/category search.
 * In addition to the search string i.e the POI name VR has to specify the search scope whether the search is for a city/state, Near by search.
 * In case of an active route guidance search scope will be extended to Nearby destination and along the route.
 */
NSAddressWithIdInfos NavigationServiceAdaptor::requestFreeTextSearchResults(const QString &searchString, uint searchScope, uchar destinationIndex, uint startIndex, uint numElements)
{
    // handle method call org.bosch.cm.navigation.NavigationService.requestFreeTextSearchResults
    return m_Service->requestFreeTextSearchResults(
        searchString,
        searchScope,
        destinationIndex,
        startIndex,
        numElements);
}

/**
 * \brief Request for inserted way points list.
 * Waypoint list provided on property update ROUTE_WAYPOINTINFOS_CHANGED. VR
 *
 * Before inserting a waypoint VR has to know the current active waypoints. For this VR will call requestWaypointList method.
 * In turn navi will send the response in the form of property update which is accomplished via WaypointListElement attribute.
 */
void NavigationServiceAdaptor::requestWaypointList()
{
    // handle method call org.bosch.cm.navigation.NavigationService.requestWaypointList
    m_Service->requestWaypointList();
}

/**
 * \brief Retrigger the last voice output (guidance).
 *
 * Method will repeat the last played navigation announcement when there is an active route guidance.
 */
void NavigationServiceAdaptor::retriggerAcousticOutput()
{
    // handle method call org.bosch.cm.navigation.NavigationService.retriggerAcousticOutput
    QMetaObject::invokeMethod(m_Service, "retriggerAcousticOutput");
}

/**
 * \brief Request will validate the given address, as result it update the attribute sdsAddressWithOptions.
 *
 * When VR wants to set a destination by address, the address details will be sent to navigation via this method. The individual address details like country name, state/provice name, city name, street name has to be sent.
 * There will be response with empty parameters.The actual result of the address search will be updated with the property sdsAddressWithOptions.
 */
void NavigationServiceAdaptor::sdsCheckAddress(NSSDSAddress requestedAddress)
{
//    qDebug() << "NavigationServiceAdaptor:::sdsCheckAddress. count:" << requestedAddress.size();
    // handle method call org.bosch.cm.navigation.NavigationService.sdsCheckAddress
    m_Service->sdsCheckAddress(requestedAddress);
}

/**
 * \brief Request will get house number patterns and the minimum and maximum values of the current SDSAddress. VR
 *
 * Method used by VR to get the house number patterns.
 * The house number for a given street can be in any range and can follow any pattern 
 * which depends on the region.
 * If the user is unsure of the house number or if he speaks a wrong house number 
 * the VR will assist in displaying the house number range in HMI from which user can select 
 * the exact one
 */
QString NavigationServiceAdaptor::sdsGetHouseNumberPattern(QString &maxHouseNumber, QStringList &patterns)
{
    // handle method call org.bosch.cm.navigation.NavigationService.sdsGetHouseNumberPattern
    return m_Service->sdsGetHouseNumberPattern(maxHouseNumber, patterns);
}

/**
 * \brief Request will get refinement list for the validated address. VR
 *
 * When VR has requested for an address search the address may sometime not be unique. In case if there are more than one city with the same name in a state/country VR has to resolve this ambiguous location.
 * So VR will get the this ambiguous list from Navigation so that we can get the unique address which user wants to set as destination
 */
NSRefinementWithIdInfos NavigationServiceAdaptor::sdsGetRefinementList()
{
    // handle method call org.bosch.cm.navigation.NavigationService.sdsGetRefinementList
    return m_Service->sdsGetRefinementList();
}

/**
 * \brief Request to show the nearby POI category. TCU
 *
 */
void NavigationServiceAdaptor::selectPoiCategoryShortcut(uchar shortcutIndex)
{
    // handle method call org.bosch.cm.navigation.NavigationService.selectPoiCategoryShortcut
    m_Service->selectPoiCategoryShortcut(shortcutIndex);
}

/**
 * \brief Request will select the refinement with the id from refinement list and add internal to SDSAddress. As result it update the attribute sdsAddressWithOptions.
 *
 * Once VR receives the ambiguous list from Navigation and user has to select an entry from this list. 
 * Each entry will be associated with an id from which the user selects and the same has to be sent to navigation.
 * For  the selected entry the route guidance will be started
 */
void NavigationServiceAdaptor::selectSdsRefinement(uint id)
{
//    qDebug() << "NavigationServiceAdaptor:::selectSdsRefinement. id:" << id;
    // handle method call org.bosch.cm.navigation.NavigationService.selectSdsRefinement
    m_Service->selectSdsRefinement(id);
}

/**
 * \brief Request to set the latitude and longitude value. TCU,SXM,VR
 */
void NavigationServiceAdaptor::setLocationWithCoordinates(NSPositionWGS84 location)
{
//    qDebug() << "NavigationServiceAdaptor:::setLocationWithSdsInput.";
    // handle method call org.bosch.cm.navigation.NavigationService.setLocationWithCoordinates
    m_Service->setLocationWithCoordinates(location);
}

/**
 * \brief Request will set location with destination memory entry id, 
 *  At least once its required to request last destination/address book list before calling this interface
 *
 */
void NavigationServiceAdaptor::setLocationWithDestinationMemoryEntry(qulonglong id)
{
    // handle method call org.bosch.cm.navigation.NavigationService.setLocationWithDestinationMemoryEntry
    m_Service->setLocationWithDestinationMemoryEntry(id);
}

/**
 * \brief Request to set the latitude and longitude value and location details for further processing.
 */
void NavigationServiceAdaptor::setLocationWithDetails(NSPOILocation location)
{
    // handle method call org.bosch.cm.navigation.NavigationService.setLocationWithDetails
    m_Service->setLocationWithDetails(location);
}

/**
 * \brief Cleanup FTS search and set the given search result as current location, so that it can be started afterwards with startGuidance() .
 *
 * If the requested POI is found then VR has to confirm that this POI has to be set as destination 
 * by calling this interface followed by which start guidance will be called
 */
void NavigationServiceAdaptor::setLocationWithFreeTextSearchInput(uint id)
{
    // handle method call org.bosch.cm.navigation.NavigationService.setLocationWithFreeTextSearchInput
    m_Service->setLocationWithFreeTextSearchInput(id);
}

/**
 * \brief Request will set the SDS Address as destination or waypoint. VR
 *
 * Once a destination is finalized after all refinements (if any) VR will call this interface to set that address as destination.
 */
void NavigationServiceAdaptor::setLocationWithSdsInput()
{
    // handle method call org.bosch.cm.navigation.NavigationService.setLocationWithSdsInput
    m_Service->setLocationWithSdsInput();
}

/**
 * \brief Select map representation:  dimension/heading combination. VR
 *
 * Method used to set the representation of map in 2D, 3D, Heading up and North up view.
 */
void NavigationServiceAdaptor::setMapRepresentation(uint representation)
{
    // handle method call org.bosch.cm.navigation.NavigationService.setMapRepresentation
    m_Service->toSetMapRepresentation(representation);
}

/**
 * \brief Set RouteCriterion settings and apply them to recalculate.
 *
 * Method called by VR to set the route criterion type.
 * This include SHORTEST, ECONOMICAL and FASTEST routes. 
 * VR will set any one of this type based on the user request and navigation will recalculate the route for an existing destination based on this
 */
void NavigationServiceAdaptor::setRouteCriterion(uint routeCriterion)
{
    // handle method call org.bosch.cm.navigation.NavigationService.setRouteCriterion
    m_Service->setRouteCriterion(routeCriterion);
}

/**
 * \brief Set and get the guidance settings element for voice.
 *
 * Method that can be used by VR to toggle the voice guidance ON or OFF.
 */
void NavigationServiceAdaptor::setVoiceGuidance(bool active)
{
    qDebug() << Q_FUNC_INFO;
    // handle method call org.bosch.cm.navigation.NavigationService.setVoiceGuidance
    m_Service->toSetVoiceGuidance(active);
}

/**
 * \brief Request to zoom in the given step count.
 *
 * Map will be zoomed in to the requested level.
 */
void NavigationServiceAdaptor::setZoomInStep(uchar zoomInStep)
{
    // handle method call org.bosch.cm.navigation.NavigationService.setZoomInStep
    m_Service->setZoomInStep(zoomInStep);
}

/**
 * \brief Request zooms to the given zoom level.
 */
void NavigationServiceAdaptor::setZoomLevel(uint zoomLevel)
{
    qDebug() << Q_FUNC_INFO;
    // handle method call org.bosch.cm.navigation.NavigationService.setZoomLevel
    m_Service->setZoomLevel(zoomLevel);
}

/**
 * \brief Request to zoom out the given step count.
 *
 * Map will be zoomed out to the requested level.
 */
void NavigationServiceAdaptor::setZoomOutStep(uchar zoomOutStep)
{
    // handle method call org.bosch.cm.navigation.NavigationService.setZoomOutStep
    m_Service->setZoomOutStep(zoomOutStep);
}

void NavigationServiceAdaptor::showAdjustCurrentLocationScreen()
{
    // handle method call org.bosch.cm.navigation.NavigationService.showAdjustCurrentLocationScreen
    m_Service->showAdjustCurrentLocationScreen();
}

/**
 * \brief Request to set the latitude and longitude value and 
*   location details for showing them and for further processing.  TCU
 *
 */
void NavigationServiceAdaptor::showAndSetLocationWithDetails(NSPOILocation location)
{
    m_Service->showAndSetLocationWithDetails(location);
}


/**
 * \brief Request will show route calculation screen with a route to the given list of 
 *   locations each of which can have their own route criterion. TCU
 *
 */
void NavigationServiceAdaptor::showCalculateTour(NSTour tour, uint screenTransition)
{
    // handle method call org.bosch.cm.navigation.NavigationService.showCalculateTour
    m_Service->showCalculateTour(QVariant::fromValue(tour), screenTransition);
}

/**
 * \brief Request shows the carsor Location on map. TCU
 *
 */
void NavigationServiceAdaptor::showCarsorLocationOnMap()
{
    // handle method call org.bosch.cm.navigation.NavigationService.showCarsorLocationOnMap
    m_Service->showCarsorLocationOnMap();
}

/**
 * \brief Show the screen to modify  waypoint list . VR
 *
 * When the waypoint list is full user has option to delete an entry from the waypoint list.
 * Currently we cannot delete an entry by VR so we display in HMI the complete waypoint list so that user can delete any one among that list.
 */
void NavigationServiceAdaptor::showDeleteWaypointListScreen()
{
    // handle method call org.bosch.cm.navigation.NavigationService.showDeleteWaypointListScreen
    m_Service->showDeleteWaypointListScreen();
}
/**
 * \brief Request will respond with a contextSwitch to Navigation Destination Free text search
 */
void NavigationServiceAdaptor::showDestinationFreeTextSearchInput(uint locationType, uint locationSearchScope, const QString& searchString)
{
    m_Service->showDestinationFreeTextSearchInput(locationType, locationSearchScope, searchString);
}

NSDestinationMemoryDetailListElement NavigationServiceAdaptor::showLocationSelectionAndGetAddressDetails()
{
    NSDestinationMemoryDetailListElement detailList;
    return detailList;   
}

/**
 * \brief Request shows the given location on map. TCU
 *
 */
void NavigationServiceAdaptor::showOnMap(NSPositionWGS84 location)
{
    // handle method call org.bosch.cm.navigation.NavigationService.showOnMap
    m_Service->showOnMap(location);
}

/**
 * \brief Request will be provide the “Show POI location“ from TCU
 *
 *  NOK - skt needs to develop new interface.
 */
void NavigationServiceAdaptor::showPOILocationFromTCU(NSPOILocations poiLocations)
{
    // handle method call org.bosch.cm.navigation.NavigationService.showPOILocationFromTCU
    m_Service->showPOILocationFromTCU(poiLocations);
}

/**
 * \brief Show the current position. Cluster, VR
 *
 * This should show the relevant information about the current vehicle position on the HMI screen.
 * This shall include information like Geo position (Latitude & longitude), current state, current city etc.
 */
void NavigationServiceAdaptor::showWhereAmIScreen()
{
    // handle method call org.bosch.cm.navigation.NavigationService.showWhereAmIScreen
    m_Service->showWhereAmIScreen();
}

/**
 * \brief method to trigger the sample voice Phrase. VR
 *
 * VR would always call  this interface with the enum value SAMPLE_PHRASE__VOICE_OUTPUT.
 * Navi should play a sample command in the set volume. Also all the TBT which follows that 
 * will be in the set volume
 * @param[in] sampleVoicePhrase by SampleVoicePhrase
 */
void NavigationServiceAdaptor::speakSamplePhrase(uint sampleVoicePhrase)
{
    m_Service->speakSamplePhrase(sampleVoicePhrase);
}

/**
 * \brief Start the guidance with the current LI / SDS destination. TCU, VR
 *
 * Method will start the route guidance to the destination that has been set via VR.
 */
void NavigationServiceAdaptor::startGuidance()
{
    // handle method call org.bosch.cm.navigation.NavigationService.startGuidance
    m_Service->doStartGuidance();
}

/**
 * \brief Start the guidance to home location. VR
 *
 * Method will start the route guidance to the address that has been stored as home address 
 * when requested via VR.
 */
void NavigationServiceAdaptor::startGuidanceToHomeLocation()
{
    // handle method call org.bosch.cm.navigation.NavigationService.startGuidanceToHomeLocation
    m_Service->startGuidanceToHomeLocation();
}

/**
 * \brief Request will start a guidance to the given WGS84 position. TCU
 */
void NavigationServiceAdaptor::startGuidanceToPosWGS84(NSPositionWGS84 destination)
{
    // handle method call org.bosch.cm.navigation.NavigationService.startGuidanceToPosWGS84
    m_Service->startGuidanceToPosWGS84(destination);
}

/**
 * \brief Start the guidance to work location. VR
 *
 * Method will start the route guidance to the address that has been stored as work address
 *  when requested via VR.
 */
void NavigationServiceAdaptor::startGuidanceToWorkLocation()
{
    // handle method call org.bosch.cm.navigation.NavigationService.startGuidanceToWorkLocation
    m_Service->startGuidanceToWorkLocation();
}

NSMapVideoStreamResult NavigationServiceAdaptor::startMapVideoStream(NSMapVideoStreamDimensions mapVideoStreamDimensions, const QString &ipAddress, ushort portnumber, ushort videoType)
{
    // handle method call org.bosch.cm.navigation.NavigationService.startMapVideoStream
    qDebug() << Q_FUNC_INFO << "params: "
    << mapVideoStreamDimensions.m_width
    << "," << mapVideoStreamDimensions.m_height 
    << "," << ipAddress
    << "," << portnumber;

    return m_Service->startMapVideoStream(mapVideoStreamDimensions, ipAddress, portnumber, videoType);
}

void NavigationServiceAdaptor::storeLocationToAddressBook(NSLocation location)
{
    m_Service->storeLocationToAddressBook(location);
}

/** 
 * \brief Request to store POI location to navigation address book. TCU
 *
 */
void NavigationServiceAdaptor::storePOILocationToAddressBook(NSPOILocation poiLocation)
{
    // handle method call org.bosch.cm.navigation.NavigationService.storePOILocationToAddressBook
    m_Service->storePOILocationToAddressBook(poiLocation);
}


/**
 * \brief Request to clear the free text search elements
 */
void NavigationServiceAdaptor::undoFreeTextSearchElementSelection()
{
    m_Service->undoFreeTextSearchElementSelection();
}

